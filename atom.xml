<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Superbishop.github.io</id>
    <title>Bishop&apos;s Blog</title>
    <updated>2020-07-04T08:38:55.433Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Superbishop.github.io"/>
    <link rel="self" href="https://Superbishop.github.io/atom.xml"/>
    <subtitle>Live and learn. </subtitle>
    <logo>https://Superbishop.github.io/images/avatar.png</logo>
    <icon>https://Superbishop.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Bishop&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[《SQL必知必会》学习笔记-2020-6-7]]></title>
        <id>https://Superbishop.github.io/post/lesslesssql-bi-zhi-bi-hui-greatergreater-xue-xi-bi-ji-2020-6-7/</id>
        <link href="https://Superbishop.github.io/post/lesslesssql-bi-zhi-bi-hui-greatergreater-xue-xi-bi-ji-2020-6-7/">
        </link>
        <updated>2020-06-07T12:45:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="用通配符进行过滤">用通配符进行过滤</h1>
<h4 id="like-操作符">LIKE 操作符</h4>
<h5 id="通配符wildcard">通配符（wildcard）</h5>
<p>用来匹配值的一部分的特殊字符。</p>
<p>为在搜索子句中使用通配符，必须使用LIKE 操作符。LIKE指示DBMS，后跟的搜索模式利用通配符匹配而不是简单的相等匹配进行比较。</p>
<blockquote>
<p>通配符搜索只能用于文本字段（字符串），非文本数据类型字段不能使用通配符搜索。</p>
</blockquote>
<h5 id="百分号通配符">百分号（%）通配符</h5>
<p>最常使用的通配符是百分号（%）。在搜索串中，%表示任何字符出现任意次数.</p>
<p>输入▼</p>
<pre><code>SELECT prod_id, prod_name
FROM Products
WHERE prod_name LIKE 'Fish%';
</code></pre>
<blockquote>
<p>说明：Access 通配符<br>
如果使用的是Microsoft Access，需要使用*而不是%。</p>
</blockquote>
<p>通配符可在搜索模式中的任意位置使用，并且可以使用多个通配符.</p>
<p>输入▼</p>
<pre><code>SELECT prod_id, prod_name
FROM Products
WHERE prod_name LIKE '%bean bag%';
</code></pre>
<p>通配符也可以出现在搜索模式的中间，虽然这样做不太有用.</p>
<p>输入▼</p>
<pre><code>SELECT prod_name
FROM Products
WHERE prod_name LIKE 'F%y';
</code></pre>
<blockquote>
<p>说明：请注意后面所跟的空格<br>
包括Access 在内的许多DBMS 都用空格来填补字段的内容。</p>
</blockquote>
<blockquote>
<p>注意：请注意NULL<br>
通配符%看起来像是可以匹配任何东西，但有个例外，这就是NULL。<br>
子句WHERE prod_name LIKE '%'不会匹配产品名称为NULL 的行。</p>
</blockquote>
<p>#####下划线（_）通配符</p>
<p>另一个有用的通配符是下划线（_）。下划线的用途与%一样，但它只匹配<strong>单个字符</strong>，而不是多个字符。</p>
<blockquote>
<p>DB2 不支持通配符_。<br>
如果使用的是Microsoft Access，需要使用?而不是_。</p>
</blockquote>
<p>对比一下两个例子,观察下划线与百分号通配符区别.</p>
<ul>
<li>输入▼</li>
</ul>
<pre><code>SELECT prod_id, prod_name
FROM Products
WHERE prod_name LIKE '__ inch teddy bear';
</code></pre>
<p>​                输出▼</p>
<pre><code>prod_id prod_name
-------- --------------------
BR02 12 inch teddy bear
BR03 18 inch teddy bear
</code></pre>
<ul>
<li>输入▼</li>
</ul>
<pre><code>SELECT prod_id, prod_name
FROM Products
WHERE prod_name LIKE '% inch teddy bear';
</code></pre>
<p>​                 输出▼</p>
<pre><code>prod_id prod_name
-------- --------------------
BR01 8 inch teddy bear
BR02 12 inch teddy bear
BNR3 18 inch teddy bear
</code></pre>
<p>与%能匹配0 个字符不同，_总是刚好匹配一个字符，不能多也不能少.</p>
<h5 id="方括号-通配符">方括号（[ ]）通配符</h5>
<p>方括号（[]）通配符用来指定一个字符集，它必须匹配指定位置（通配符的位置）的一个字符.</p>
<blockquote>
<p>说明：并不总是支持集合<br>
与前面描述的通配符不一样，并不是所有DBMS 都支持用来创建集合<br>
的[]。只有微软的Access 和SQL Server 支持集合。为确定你使用的<br>
DBMS 是否支持集合，请参阅相应的文档。</p>
</blockquote>
<p>此通配符可以用前缀字符^（脱字号）来否定。</p>
<p>如果使用的是Microsoft Access，需要用!而不是^来否定一个集合.</p>
<p>NOT 操作符可得出类似的结果。^的唯一优点是在使用多个WHERE 子句时可以简化语法.</p>
<h5 id="使用通配符的技巧">使用通配符的技巧</h5>
<ul>
<li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用<br>
其他操作符。</li>
<li>在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始<br>
处。把通配符置于开始处，搜索起来是最慢的。</li>
<li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《SQL必知必会》学习笔记-2020-6-6]]></title>
        <id>https://Superbishop.github.io/post/lesslesssql-bi-zhi-bi-hui-greatergreater-xue-xi-bi-ji-2020-6-6/</id>
        <link href="https://Superbishop.github.io/post/lesslesssql-bi-zhi-bi-hui-greatergreater-xue-xi-bi-ji-2020-6-6/">
        </link>
        <updated>2020-06-06T03:49:17.000Z</updated>
        <content type="html"><![CDATA[<h1 id="排序检索数据">排序检索数据</h1>
<h4 id="子句clause">子句（clause）</h4>
<p>SQL 语句由子句构成，有些子句是必需的，有些则是可选的。一个子句通常由一个关键字加上所提供的数据组成。</p>
<p>为了明确地排序用SELECT 语句检索出的数据，可使用ORDER BY 子句。<br>
ORDER BY 子句取一个或多个列的名字，据此对输出进行排序</p>
<p>输入▼</p>
<pre><code>SELECT prod_name
FROM Products
ORDER BY prod_name;
</code></pre>
<blockquote>
<p>在指定一条ORDER BY 子句时，应该保证它是SELECT 语句中最后一条子句。如果它不是最后的子句，将会出现错误消息。</p>
</blockquote>
<hr>
<h4 id="按多个列排序">按多个列排序</h4>
<p>要按多个列排序，简单指定列名，列名之间用逗号分开即可（就像选择多个列时那样）。</p>
<p>输入▼</p>
<pre><code>SELECT prod_id, prod_price, prod_name
FROM Products
ORDER BY prod_price, prod_name;
</code></pre>
<p>输出▼</p>
<pre><code>prod_id prod_price prod_name
---
BNBG02 3.4900 Bird bean bag toy
BNBG01 3.4900 Fish bean bag toy
BNBG03 3.4900 Rabbit bean bag toy
RGAN01 4.9900 Raggedy Ann
BR01 5.9900 8 inch teddy bear
BR02 8.9900 12 inch teddy bear
RYL01 9.4900 King doll
RYL02 9.4900 Queen doll
BR03 11.9900 18 inch teddy bear

</code></pre>
<hr>
<h4 id="按列位置排序">按列位置排序</h4>
<p>除了能用列名指出排序顺序外，ORDER BY 还支持按相对列位置进行排序。</p>
<p>输入▼</p>
<pre><code>SELECT prod_id, prod_price, prod_name
FROM Products
ORDER BY 2, 3;
</code></pre>
<p>输出▼</p>
<pre><code>prod_id prod_price prod_name
------- ---------- --------------------
BNBG02 3.4900 Bird bean bag toy
BNBG01 3.4900 Fish bean bag toy
BNBG03 3.4900 Rabbit bean bag toy
RGAN01 4.9900 Raggedy Ann
BR01 5.9900 8 inch teddy bear
BR02 8.9900 12 inch teddy bear
RYL01 9.4900 King doll
RYL02 9.4900 Queen doll
BR03 11.9900 18 inch teddy bear
</code></pre>
<blockquote>
<p>这一技术的主要好处在于不用重新输入列名。但它也有缺点。首先，不明<br>
确给出列名有可能造成错用列名排序。其次，在对SELECT 清单进行更改<br>
时容易错误地对数据进行排序（忘记对ORDER BY 子句做相应的改动）。<br>
最后，如果进行排序的列不在SELECT 清单中，显然不能使用这项技术。</p>
</blockquote>
<hr>
<h4 id="指定排序方向">指定排序方向</h4>
<p>数据排序不限于升序排序（从A 到Z），这只是默认的排序顺序。还可以使用ORDER BY 子句进行降序（从Z 到A）排序。为了进行降序排序，必须指定<strong>DESC</strong> 关键字。</p>
<p>输入▼</p>
<pre><code>SELECT prod_id, prod_price, prod_name
FROM Products
ORDER BY prod_price DESC;
</code></pre>
<p>输出▼</p>
<pre><code>prod_id prod_price prod_name
------- ---------- --------------------
BR03 11.9900 18 inch teddy bear
RYL01 9.4900 King doll
RYL02 9.4900 Queen doll
BR02 8.9900 12 inch teddy bear
BR01 5.9900 8 inch teddy bear
RGAN01 4.9900 Raggedy Ann
BNBG01 3.4900 Fish bean bag toy
BNBG02 3.4900 Bird bean bag toy
BNBG03 3.4900 Rabbit bean bag toy
</code></pre>
<blockquote>
<p><strong>如果想在多个列上进行降序排序，必须对每一列指定DESC 关键字。</strong></p>
</blockquote>
<hr>
<h1 id="过滤数据">过滤数据</h1>
<p>如何使用SELECT 语句的WHERE 子句指定搜索条件。</p>
<h4 id="使用where-子句">使用WHERE 子句</h4>
<p>在SELECT 语句中，数据根据WHERE 子句中指定的搜索条件进行过滤。WHERE 子句在表名（FROM 子句）之后给出。</p>
<p>输入▼</p>
<pre><code>SELECT prod_name, prod_price
FROM Products
WHERE prod_price = 3.49;
</code></pre>
<p>输出▼</p>
<pre><code>prod_name prod_price
------------------- ----------
Fish bean bag toy 3.49
Bird bean bag toy 3.49
Rabbit bean bag toy 3.49
</code></pre>
<blockquote>
<p>这条语句从products 表中检索两个列，但不返回所有行，只返回<br>
prod_price 值为3.49 的行</p>
</blockquote>
<p><strong>在同时使用ORDER BY 和WHERE 子句时，应该让ORDER BY 位于WHERE 之后，否则将会产生错误</strong></p>
<hr>
<h4 id="where-子句操作符">WHERE 子句操作符</h4>
<p>SQL 支持下表 列出的所有条件操作符。</p>
<figure data-type="image" tabindex="1"><img src="https://Superbishop.github.io/post-images/1591415615769.png" alt="" loading="lazy"></figure>
<hr>
<h4 id="检查单个值">检查单个值</h4>
<p>列出所有价格小于10 美元的产品：</p>
<p>输入▼</p>
<pre><code>SELECT prod_name, prod_price
FROM Products
WHERE prod_price &lt; 10;
</code></pre>
<p>输出▼</p>
<pre><code>prod_name prod_price
------------------- ----------
Fish bean bag toy 3.49
Bird bean bag toy 3.49
Rabbit bean bag toy 3.49
8 inch teddy bear 5.99
12 inch teddy bear 8.99
Raggedy Ann 4.99
King doll 9.49
Queen doll 9.49
</code></pre>
<p>检索所有价格小于等于10 美元的产品：</p>
<p>输入▼</p>
<pre><code>SELECT prod_name, prod_price
FROM Products
WHERE prod_price &lt;= 10;
</code></pre>
<hr>
<h4 id="不匹配检查">不匹配检查</h4>
<p>列出所有不是供应商DLL01 制造的产品：</p>
<p>输入▼</p>
<pre><code>SELECT vend_id, prod_name
FROM Products
WHERE vend_id &lt;&gt; 'DLL01';
</code></pre>
<p>输出▼</p>
<pre><code>vend_id prod_name
---------- ------------------
BRS01 8 inch teddy bear
BRS01 12 inch teddy bear
BRS01 18 inch teddy bear
FNG01 King doll
FNG01 Queen doll
</code></pre>
<p><strong>何时使用引号？</strong></p>
<p>单引号用来限定字符串。如果将值与字符串类型的列进行比较，就需要限定引号。用来与数值列进行比较的值不用引号。</p>
<hr>
<h4 id="范围值检查">范围值检查</h4>
<p>要检查某个范围的值，可以使用BETWEEN 操作符。其语法与其他WHERE子句的操作符稍有不同，因为它需要两个值，即范围的开始值和结束值。</p>
<p>输入▼</p>
<pre><code>SELECT prod_name, prod_price
FROM Products
WHERE prod_price BETWEEN 5 AND 10;
</code></pre>
<p>输出▼</p>
<pre><code>prod_name prod_price
------------------- ----------
8 inch teddy bear 5.99
12 inch teddy bear 8.99
King doll 9.49
Queen doll 9.49
</code></pre>
<hr>
<h4 id="空值检查">空值检查</h4>
<p>在创建表时，表设计人员可以指定其中的列能否不包含值。在一个列不包含值时，称其包含<strong>空值NULL</strong>。</p>
<blockquote>
<p>NULL<br>
无值（no value），它与字段包含0、空字符串或仅仅包含空格不同。</p>
</blockquote>
<p>SELECT 语句有一个特殊的WHERE 子句，可用来检查具有NULL 值的列。这个WHERE 子句就是<strong>IS NULL</strong> 子句。</p>
<p>输入▼</p>
<pre><code>SELECT prod_name
FROM Products
WHERE prod_price IS NULL;
</code></pre>
<blockquote>
<p>注意：NULL 和非匹配<br>
通过过滤选择不包含指定值的所有行时，你可能希望返回含NULL 值<br>
的行。但是这做不到。因为未知（unknown）有特殊的含义，数据库<br>
不知道它们是否匹配，所以在进行匹配过滤或非匹配过滤时，不会返<br>
回这些结果。<br>
过滤数据时，一定要验证被过滤列中含NULL 的行确实出现在返回的<br>
数据中。</p>
</blockquote>
<hr>
<h1 id="高级数据过滤">高级数据过滤</h1>
<p>如何组合WHERE 子句以建立功能更强、更高级的搜索条件？</p>
<p>如何使用NOT 和IN 操作符？</p>
<h4 id="组合where-子句">组合WHERE 子句</h4>
<p>为了进行更强的过滤控制，SQL 允许给出多个WHERE 子句。这些子句有两<br>
种使用方式，即以<strong>AND 子句或OR 子句</strong>的方式使用。</p>
<blockquote>
<p>操作符（operator）<br>
用来联结或改变WHERE 子句中的子句的关键字，也称为逻辑操作符<br>
（logical operator）。</p>
</blockquote>
<h4 id="and操作符">AND操作符</h4>
<p>输入▼</p>
<pre><code>SELECT prod_id, prod_price, prod_name
FROM Products
WHERE vend_id = 'DLL01' AND prod_price &lt;= 4;
</code></pre>
<h4 id="or操作符">OR操作符</h4>
<p>输入▼</p>
<pre><code>SELECT prod_name, prod_price
FROM Products
WHERE vend_id = 'DLL01' OR vend_id = ‘BRS01’;
</code></pre>
<h4 id="求值顺序">求值顺序</h4>
<p>WHERE 子句可以包含任意数目的AND 和OR 操作符。允许两者结合以进行复杂、高级的过滤。但SQL（像多数语言一样）在处理OR 操作符前，优先处理AND 操作符。</p>
<p>若想优先处理OR子句,解决方法是使用<strong>圆括号</strong>对操作符进行明确分组.</p>
<p>对比一下两个例子,可得出,通过使用圆括号,输出结果截然不同.</p>
<ol>
<li></li>
</ol>
<p>输入▼</p>
<pre><code>SELECT prod_name, prod_price
FROM Products
WHERE vend_id = 'DLL01' OR vend_id = 'BRS01'
AND prod_price &gt;= 10;
</code></pre>
<p>输出▼</p>
<pre><code>prod_name prod_price
------------------- ----------
Fish bean bag toy 3.4900
Bird bean bag toy 3.4900
Rabbit bean bag toy 3.4900
18 inch teddy bear 11.9900
Raggedy Ann 4.9900
</code></pre>
<ol start="2">
<li></li>
</ol>
<p>输入▼</p>
<pre><code>SELECT prod_name, prod_price
FROM Products
WHERE (vend_id = 'DLL01' OR vend_id = 'BRS01')
AND prod_price &gt;= 10;
</code></pre>
<p>输出▼</p>
<pre><code>prod_name prod_price
------------------- ----------
18 inch teddy bear 11.9900
</code></pre>
<blockquote>
<p>提示：在WHERE 子句中使用圆括号<br>
任何时候使用具有AND 和OR 操作符的WHERE 子句，都应该使用圆括<br>
号明确地分组操作符。不要过分依赖默认求值顺序，即使它确实如你<br>
希望的那样。使用圆括号没有什么坏处，它能消除歧义。</p>
</blockquote>
<p>​</p>
<h4 id="in-操作符">IN 操作符</h4>
<p>IN 操作符用来指定条件范围，范围中的每个条件都可以进行匹配。IN 取一组由逗号分隔、括在圆括号中的合法值.</p>
<p>输入▼</p>
<pre><code>SELECT prod_name, prod_price
FROM Products
WHERE vend_id IN ( 'DLL01', 'BRS01' )
ORDER BY prod_name;
</code></pre>
<p>输出▼</p>
<pre><code>prod_name prod_price
------------------- ----------
12 inch teddy bear 8.9900
18 inch teddy bear 11.9900
8 inch teddy bear 5.9900
Bird bean bag toy 3.4900
Fish bean bag toy 3.4900
Rabbit bean bag toy 3.4900
Raggedy Ann 4.9900
</code></pre>
<p>IN 操作符看似与OR操作符如出同辙,但IN操作符更具优势.</p>
<ul>
<li>
<p>在有很多合法选项时，IN 操作符的语法<strong>更清楚，更直观</strong>。</p>
</li>
<li>
<p>在与其他AND 和OR 操作符组合使用IN 时，<strong>求值顺序更容易管理</strong>。</p>
</li>
<li>
<p><strong>IN 操作符一般比一组OR 操作符执行得更快</strong>（在上面这个合法选项很少的例子中，你看不出性能差异）。</p>
</li>
<li>
<p><strong>IN 的最大优点是可以包含其他SELECT 语句，能够更动态地建立WHERE 子句</strong></p>
</li>
</ul>
<h4 id="not-操作符">NOT 操作符</h4>
<p>WHERE 子句中用来否定其后条件的关键字.</p>
<p>输入▼</p>
<pre><code>SELECT prod_name
FROM Products
WHERE NOT vend_id = 'DLL01'
ORDER BY prod_name;
</code></pre>
<p>输出▼</p>
<pre><code>prod_name
------------------
12 inch teddy bear
18 inch teddy bear
8 inch teddy bear
King doll
Queen doll
</code></pre>
<p>为什么使用NOT？</p>
<p>对于这里的这种简单的WHERE 子句，使用NOT 确实没有什么优势。但在更复杂的子句中，NOT 是非常有用的。例如，在与IN 操作符联合使用时，NOT 可以非常简单地找出与条件列表不匹配的行。</p>
<blockquote>
<p>说明：MariaDB 中的NOT<br>
MariaDB 支持使用NOT 否定IN、BETWEEN 和EXISTS 子句。大多数<br>
DBMS 允许使用NOT 否定任何条件。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《SQL必知必会》学习笔记-2020-6-5]]></title>
        <id>https://Superbishop.github.io/post/lesslesssql-bi-zhi-bi-hui-greatergreater-xue-xi-bi-ji-2020-6-5/</id>
        <link href="https://Superbishop.github.io/post/lesslesssql-bi-zhi-bi-hui-greatergreater-xue-xi-bi-ji-2020-6-5/">
        </link>
        <updated>2020-06-05T04:39:23.000Z</updated>
        <content type="html"><![CDATA[<h3 id="select-语句">SELECT 语句</h3>
<p><strong>用途是从一个或多个表中检索信息。</strong></p>
<h4 id="关键字keyword">关键字（keyword）</h4>
<p>作为SQL 组成部分的保留字。关键字不能用作表或列的名字。</p>
<p>为了使用SELECT 检索表数据，必须至少给出两条信息——想选择什么，<br>
以及从什么地方选择。</p>
<p>SQL 是一种语言而不是一个应用程序。</p>
<p>具体如何写SQL 语句并显示语句输出，是随不同的应用程序而变化的</p>
<hr>
<h4 id="检索单个列">检索单个列</h4>
<p>利用SELECT 语句从Products 表中检索一个名为prod_name的列。</p>
<p>输入：</p>
<pre><code>SELECT prod_name
FROM Products;
</code></pre>
<p>输出：</p>
<pre><code>prod_name
-------------------
Fish bean bag toy
Bird bean bag toy
Rabbit bean bag toy
8 inch teddy bear
12 inch teddy bear
18 inch teddy bear
Raggedy Ann
King doll
Queen doll
</code></pre>
<hr>
<h4 id="sql书写规范">SQL书写规范</h4>
<ol>
<li>
<p>多条SQL 语句必须以分号（；）分隔。</p>
</li>
<li>
<p>SQL 语句不区分大小写，因此SELECT 与select 是相同的。同样，写成Select 也没有关系。许多SQL 开发人员喜欢对<strong>SQL 关键字使用大写</strong>，而<strong>对列名和表名使用小写</strong>，这样做使代码更<em>易于阅读和调试</em>。</p>
</li>
<li>
<p>在处理SQL 语句时，其中所有空格都被忽略。以下三种写法等效的，但第一、三种写法符合多数SQL 开发人员习惯，便于阅读和调试。</p>
<pre><code>SELECT prod_name
FROM Products;

SELECT prod_name FROM Products;

SELECT
prod_name
FROM
Products;
</code></pre>
</li>
</ol>
<hr>
<h4 id="检索多个列">检索多个列</h4>
<p>在SELECT 关键字后给出多个列名，列名之间必须以逗号分隔。</p>
<p>输入：</p>
<pre><code>SELECT prod_id, prod_name, prod_price
FROM Products;
</code></pre>
<p>输出：</p>
<pre><code>prod_id prod_name prod_price
--------- -------------------- ----------
BNBG01 Fish bean bag toy 3.4900
BNBG02 Bird bean bag toy 3.4900
BNBG03 Rabbit bean bag toy 3.4900
BR01 8 inch teddy bear 5.9900
BR02 12 inch teddy bear 8.9900
BR03 18 inch teddy bear 11.9900
RGAN01 Raggedy Ann 4.9900
RYL01 King doll 9.4900
RYL02 Queen dool 9.4900
</code></pre>
<blockquote>
<p>SQL 语句一般返回原始的、无格式的数据。数据的格式化是表示问题，而不是检索问题。因此，表示（如把上面的价格值显示为正确的十进制数值货币金额）一般在显示该数据的应用程序中规定。通常很少直接使用实际检索出的数据（没有应用程序提供的格式）。</p>
</blockquote>
<hr>
<h4 id="检索所有列">检索所有列</h4>
<p>除了指定所需的列外（如上所述，一个或多个列），SELECT 语句还可以<br>
检索所有的列而不必逐个列出它们。在实际列名的位置使用星号（*）通<br>
配符可以做到这点，如下所示。<br>
输入▼</p>
<pre><code>SELECT *
FROM Products;
</code></pre>
<blockquote>
<p>缺点：检索不需要的列通常会降低检索和应用程序的性能</p>
</blockquote>
<blockquote>
<p>优点：由于不明确指定列名（因为星号检索每一列），所以能检索出名字未知的列</p>
</blockquote>
<hr>
<h4 id="检索不同的值">检索不同的值</h4>
<p>检索products 表中所有产品供应商的ID：</p>
<p>输入▼</p>
<pre><code>SELECT vend_id
FROM Products;
</code></pre>
<p>输出▼</p>
<pre><code>vend_id
------
BRS01
BRS01
BRS01
DLL01
DLL01
DLL01
DLL01
FNG01
FNG01
</code></pre>
<blockquote>
<p>SELECT 语句返回9 行（即使表中只有3 个产品供应商），因为products表中有9 种产品。</p>
</blockquote>
<p>检索出不同的值</p>
<p>输入▼</p>
<pre><code>SELECT DISTINCT vend_id
FROM Products;
</code></pre>
<p>输出▼</p>
<pre><code>vend_id
------
BRS01
DLL01
FNG01
</code></pre>
<p><strong>如果使用DISTINCT 关键字，它必须直接放在列名的前面。</strong></p>
<hr>
<h4 id="限制结果">限制结果</h4>
<p>SELECT 语句返回指定表中所有匹配的行，很可能是每一行。如果你只想<br>
返回第一行或者一定数量的行，该怎么办呢？</p>
<ul>
<li>在SQL Server 和Access 中使用SELECT 时，可以使用TOP 关键字来限制最多返回多少行，如下所示：</li>
</ul>
<p>输入▼</p>
<pre><code>SELECT TOP 5 prod_name
FROM Products;
</code></pre>
<p>输出▼</p>
<pre><code>prod_name
8 inch teddy bear
12 inch teddy bear
18 inch teddy bear
Fish bean bag toy
Bird bean bag toy
</code></pre>
<blockquote>
<p>使用SELECT TOP 5 语句，只检索前5 行数据</p>
</blockquote>
<ul>
<li>
<p>如果你使用的是DB2，很可能习惯使用下面这一DBMS 特定的SQL 语句，像这样：</p>
<p>输入▼</p>
<pre><code>SELECT prod_name
FROM Products
FETCH FIRST 5 ROWS ONLY;
</code></pre>
</li>
</ul>
<blockquote>
<p>FETCH FIRST 5 ROWS ONLY，程序会按字面意思检索前5行</p>
</blockquote>
<ul>
<li>
<p>如果你使用Oracle，需要基于ROWNUM（行计数器）来计算行，像这样：</p>
<p>输入▼</p>
<pre><code>SELECT prod_name
FROM Products
WHERE ROWNUM &lt;=5;
</code></pre>
</li>
</ul>
<blockquote>
<p>WHERE ROWNUM &lt;=5，基于ROWNUM计算</p>
</blockquote>
<ul>
<li>
<p>如果你使用MySQL、MariaDB、PostgreSQL 或者SQLite，需要使用LIMIT子句，像这样：</p>
<p>输入▼</p>
<pre><code>SELECT prod_name
FROM Products
LIMIT 5;
</code></pre>
</li>
</ul>
<blockquote>
<p>LIMIT 5 指示MySQL等DBMS 返回不超过5 行的数据</p>
</blockquote>
<ul>
<li>
<p>为了得到后面的5 行数据，需要指定从哪儿开始以及检索的行数，像这样：</p>
<p>输入▼</p>
<pre><code>SELECT prod_name
FROM Products
LIMIT 5 OFFSET 5;
</code></pre>
</li>
</ul>
<blockquote>
<p>LIMIT 5 OFFSET 5 指示MySQL 等DBMS 返回从第5 行起的5 行数据。第一个数字是指从哪儿开始，第二个数字是检索的行数。</p>
</blockquote>
<p>注意事项</p>
<ol>
<li>第一个被检索的行是第0 行，而不是第1 行。因此，LIMIT 1 OFFSET1 会检索第2 行，而不是第1 行。</li>
<li>MySQL和MariaDB支持<em>简化版的LIMIT 4 OFFSET 3语句</em>，即<em>LIMIT 3,4</em>。使用这个语法，<strong>逗号之前的值对应OFFSET</strong>，<strong>逗号之后的值对应LIMIT</strong>。</li>
<li>并非所有的SQL 实现都一样，SQL 虽然通常都有相当一致的实现，但你不能想当然地认为它总是这样。非常基本的语句往往是容易移植的，但较复杂的语句就不同了。当你针对某个问题寻找SQL解决方案时，一定要记住这一点。</li>
</ol>
<h4 id="limit-与-limit-offset使用区别">LIMIT 与 LIMIT OFFSET使用区别:</h4>
<p>LIMIT x,y =LIMIT y OFFSET x :</p>
<p>表示从y+1行开始取x行数据;</p>
<p>LIMIT x OFFSET y = LIMIT y,x :</p>
<p>表示从x+1行开始取y行数据;</p>
<hr>
<h4 id="使用注释">使用注释</h4>
<p>为什么需要添加注释？</p>
<ol>
<li>随着SQL语句边长，复杂性增加，有必要添加注释进行说明，便于自己日后调试，也便于他人参考。</li>
<li>适用于SQL开始处的内容，比如包含程序员的联系方式、程序描述及说明。</li>
<li>另一个重要应用是可以暂时停止不用执行的SQL代码。如果你碰到一个长SQL 语句，而只想测试它的一部分，那么应该注释掉一些代码。</li>
</ol>
<p>几种常见注释方法</p>
<p>行内注释：</p>
<pre><code>SELECT prod_name -- 这是一条注释
FROM Products;
</code></pre>
<pre><code>#这是一条注释
SELECT prod_name
FROM Products;
</code></pre>
<pre><code>/* SELECT prod_name, vend_id
FROM Products; */
SELECT prod_name
FROM Products;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《SQL必知必会》学习笔记-2020-6-4]]></title>
        <id>https://Superbishop.github.io/post/lesslesssql-bi-zhi-bi-hui-greatergreater-xue-xi-bi-ji-2020-6-4/</id>
        <link href="https://Superbishop.github.io/post/lesslesssql-bi-zhi-bi-hui-greatergreater-xue-xi-bi-ji-2020-6-4/">
        </link>
        <updated>2020-06-04T04:07:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="数据库database">数据库(DATABASE)</h2>
<h4 id="定义">定义</h4>
<p>保存有组织的数据的容器（通常是一个文件或一组文件）。</p>
<p>最简单的办法是将数据库想象为一个文件柜。这个文件柜是一个存放数据的物理位置，不管数据是什么，也不管数据是如何组织的。</p>
<h4 id="与数据库软件的区别">与数据库软件的区别</h4>
<p>人们通常用数据库这个术语来代表他们使用的数据库软件，这是不正确的，也因此产生了许多混淆。确切地说，数据库软件应称为数据库管理系统（DBMS）。数据库是通过DBMS 创建和操纵的容器，而具体它究竟是什么，形式如何，各种数据库都不一样。</p>
<h2 id="表table">表（table）</h2>
<h4 id="定义-2">定义</h4>
<p>某种特定类型数据的结构化清单。</p>
<p>存储在表中的数据是同一种类型的数据或清单。决不应该将顾客的清单与订单的清单存储在同一个数据库表中，否则以后的检索和访问会很困难。</p>
<p>数据库中的每个表都有一个名字来标识自己。这个名字是唯一的，即数<br>
据库中没有其他表具有相同的名字。</p>
<h4 id="表名">表名</h4>
<p>使表名成为唯一的，实际上是数据库名和表名等的组合。虽然在相同数据库中不能两次使用相同的表名，但在不同的数据库中完全可以使用相同的表名。</p>
<h4 id="模式schema">模式（schema）</h4>
<p>关于数据库和表的布局及特性的信息。</p>
<p>模式可以用来描述数据库中特定的表，也可以用来描述整个数据库（和其中表的关系）。</p>
<h2 id="列和数据类型">列和数据类型</h2>
<h4 id="列column">列（column）</h4>
<p>表中的一个字段。所有表都是由一个或多个列组成的。</p>
<h4 id="分解数据">分解数据</h4>
<p>正确地将数据分解为多个列极为重要。例如，城市、州、邮政编码<br>
应该总是彼此独立的列。通过分解这些数据，才有可能利用特定的<br>
列对数据进行分类和过滤（如找出特定州或特定城市的所有顾客）。</p>
<h4 id="数据类型">数据类型</h4>
<p>所允许的数据的类型。每个表列都有相应的数据类型，它限制（或允<br>
许）该列中存储的数据。</p>
<h4 id="注意数据类型兼容">注意：数据类型兼容</h4>
<p>数据类型及其名称是SQL 不兼容的一个主要原因。虽然大多数基本数<br>
据类型得到了一致的支持，但许多高级的数据类型却没有。更糟的是，<br>
偶然会有相同的数据类型在不同的DBMS 中具有不同的名称。对此用<br>
户毫无办法，重要的是在创建表结构时要记住这些差异。</p>
<h2 id="行row">行（row）</h2>
<h4 id="定义-3">定义</h4>
<p>表中的一个记录。</p>
<h4 id="说明是记录还是行">说明：是记录还是行？</h4>
<p>你可能听到用户在提到行时称其为数据库记录（record）。这两个术语<br>
多半是可以交替使用的，但从技术上说，行才是正确的术语。</p>
<h2 id="主键primary-key">主键（primary key）</h2>
<h4 id="定义-4">定义</h4>
<p>一列（或一组列），其值能够唯一标识表中每一行。</p>
<p>表中每一行都应该有一列（或几列）可以唯一标识自己。顾客表可以使<br>
用顾客编号，而订单表可以使用订单ID。雇员表可以使用雇员ID 或雇<br>
员社会安全号。</p>
<p>主键用来表示一个特定的行。没有主键，更新或删除表中特定行就极为困难。</p>
<h4 id="提示应该总是定义主键">提示：应该总是定义主键</h4>
<p>虽然并不总是需要主键，但多数数据库设计者都会保证他们创建的每<br>
个表具有一个主键，以便于以后的数据操作和管理。</p>
<h4 id="表中的任何列都可以作为主键只要它满足以下条件">表中的任何列都可以作为主键，只要它满足以下条件：</h4>
<p> 任意两行都不具有相同的主键值；<br>
 每一行都必须具有一个主键值（主键列不允许NULL 值）；<br>
 主键列中的值不允许修改或更新；<br>
 主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）</p>
<p>主键通常定义在表的一列上，但并不是必需这么做，也可以一起使用多<br>
个列作为主键。在使用多列作为主键时，上述条件必须应用到所有列，<br>
所有列值的组合必须是唯一的（但单个列的值可以不唯一）。</p>
<h2 id="什么是sql">什么是SQL</h2>
<p>SQL（发音为字母S-Q-L 或sequel）是Structured Query Language（结构<br>
化查询语言）的缩写。SQL 是一种专门用来与数据库沟通的语言。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[爬取豆瓣电影列表]]></title>
        <id>https://Superbishop.github.io/post/Ekr4wfa8m/</id>
        <link href="https://Superbishop.github.io/post/Ekr4wfa8m/">
        </link>
        <updated>2019-12-02T18:24:58.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://Superbishop.github.io/post-images/1578894191025.png" alt="" loading="lazy"></figure>
<pre><code>import requests
import re
import xlsxwriter

headers={&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64)\
        AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36&quot;}

url=&quot;https://movie.douban.com/j/chart/top_list?type=11&amp;interval_id=100%3A90&amp;action=&amp;start=40&amp;limit=20&quot;

response=requests.get(url,headers=headers).text

pat1=r'&quot;rating&quot;:\[&quot;(.*?)&quot;,&quot;\d+&quot;\]'
pat2=r'&quot;rank&quot;:(\d+)'
pat3=r'&quot;title&quot;:&quot;(.*?)&quot;'

pattern1=re.compile(pat1)
pattern2=re.compile(pat2)
pattern3=re.compile(pat3)

data1=re.findall(pattern1,response)
data2=re.findall(pattern2,response)
data3=re.findall(pattern3,response)

#创建表单于电脑桌面保存爬取电影排名结果
workbook=xlsxwriter.Workbook('C:doubanfilm3.xlsx')
worksheet=workbook.add_worksheet()
worksheet.write(&quot;A1&quot;,&quot;电影排名&quot;)
worksheet.write(&quot;B1&quot;,&quot;电影评分&quot;)
worksheet.write(&quot;C1&quot;,&quot;电影名&quot;)

for x in range(0,len(data1)) :
    print(&quot;电影排名:&quot;,data2[x],&quot;电影评分:&quot;,data1[x],&quot;电影名:&quot;,data3[x])

    worksheet.write(&quot;A&quot;+str(x+2),data2[x])
    worksheet.write(&quot;B&quot;+str(x+2),data1[x])
    worksheet.write(&quot;C&quot;+str(x+2),data3[x])


workbook.close()

</code></pre>
]]></content>
    </entry>
</feed>